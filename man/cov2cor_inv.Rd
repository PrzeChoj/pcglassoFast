% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/util.R
\name{cov2cor_inv}
\alias{cov2cor_inv}
\title{Invert cov2cor for one or many correlation matrices}
\usage{
cov2cor_inv(C, diagSigma)
}
\arguments{
\item{C}{A numeric correlation matrix (p×p) or an array of shape p×p×k.
Each slice C[,,i] must be a valid correlation matrix (1's on the diagonal).}

\item{diagSigma}{Either
- a numeric vector of length p (variances for each variable),
- or a numeric matrix p×k (variances for each slice).
If \code{C} is 2D, only the length-p option is used.}
}
\value{
If \code{C} is 2D, a p×p covariance matrix
  \eqn{\Sigma = D\,C\,D}, where \eqn{D = \mathrm{diag}(\sqrt{\mathrm{diagSigma}})}.
  If \code{C} is 3D (p×p×k), returns a p×p×k array of \eqn{\Sigma^{(i)}}.
}
\description{
Reconstruct covariance(s) from correlation(s) plus variances.
}
\examples{
# 2D example
Sigma <- matrix(c(4, 1.2, 1.2, 9), 2, 2)
C     <- cov2cor(Sigma)
Sigma2 <- cov2cor_inv(C, diag(Sigma))
all.equal(Sigma, Sigma2)

# 3D example: two correlation matrices sharing the same variances
C3 <- array(0, c(2,2,2))
C3[,,1] <- diag(2)
C3[,,2] <- cov2cor(Sigma)
S3 <- cov2cor_inv(C3, diag(Sigma))
dim(S3)  # 2 2 2

# 3D with slice‐specific variances
vars <- cbind(c(4,9), c(1,16))  # 2×2: first slice variances (4,9), second (1,16)
S4 <- cov2cor_inv(C3, vars)
all(dim(S4)==c(2,2,2))

}
