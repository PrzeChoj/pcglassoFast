% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/path.R
\name{pcglassoPath}
\alias{pcglassoPath}
\title{Pathwise blockwise optimization for pcglasso}
\usage{
pcglassoPath(
  S,
  alpha,
  lambdas = NULL,
  nlambda = 50,
  lambda.min.ratio = 0.01,
  R0 = diag(nrow(S)),
  R0_inv = NULL,
  D0 = rep(1, nrow(S)),
  max.iter = 100,
  tolerance = 1e-06,
  R.tol.inner = 0.01,
  R.tol.outer = 0.001,
  R.max.inner.iter = 10,
  R.max.outer.iter = 100,
  D.tol = 1e-04,
  D.max.starting.iter = 500,
  D.max.outer.iter = 100
)
}
\arguments{
\item{S}{(p × p matrix) empirical covariance matrix derived from the data.}

\item{alpha}{(double, \eqn{\alpha \in \mathbb{R}}) on‑diagonal penalty parameter.}

\item{lambdas}{(numeric vector) sequence of λ values to fit. If \code{NULL}, an exponentially spaced grid of length \code{nlambda} from
\eqn{\max_{i≠j}|S_{ij}|} down to \code{lambda.min.ratio * λ_max} is generated.}

\item{nlambda}{(integer) number of λ values when \code{lambdas = NULL}.}

\item{lambda.min.ratio}{(double) ratio \eqn{\lambda_{\min}/\lambda_{\max}} used to build the grid.}

\item{R0, R0_inv}{(p × p matrices) initial precision matrix and its inverse; defaults to \code{diag(p)}.}

\item{D0}{(numeric vector of length p) initial diagonal entries; default is \code{rep(1,p)}.}

\item{max.iter, tolerance, R.tol.inner, R.tol.outer, R.max.inner.iter, R.max.outer.iter, D.tol, D.max.starting.iter, D.max.outer.iter}{Parameters passed to \code{\link[=pcglassoFast]{pcglassoFast()}} function for every \code{lambda}.}
}
\value{
A list with components:
\describe{
\item{\code{lambdas}}{The grid of λ values actually used.}
\item{\code{R_path}}{List of estimated correlation matrices \(R\).}
\item{\code{D_path}}{List of estimated diagonal matrices \(D\).}
\item{\code{W_path}}{List of full covariance estimates \(D\,R\,D\).}
\item{\code{loss}}{Numeric vector of final objective values at each λ.}
}
}
\description{
Pathwise blockwise optimization for pcglasso
}
\details{
This function computes the entire regularization path of the PC‑GLASSO estimator by calling
\code{\link{pcglassoFast}()} at each value of \eqn{\lambda} in \code{lambdas}, warm‑starting
from the previous solution.  You get back a list of \eqn{(R,D)} pairs (and the resulting
covariance \eqn{W = D\,R\,D}) as \eqn{\lambda} decreases.
}
\examples{
p <- 7
R.true <- toeplitz(c(1, -0.5, rep(0, p-2)))
D.true <- sqrt(rchisq(p, df = 3))
S <- solve(diag(D.true) \%*\% R.true \%*\% diag(D.true))
alpha <- 4/20

# get a small path of 20 lambdas
resPath <- pcglassoPath(S, alpha,
                        nlambda = 20,
                        lambda.min.ratio = 0.05,
                        trace = TRUE)
str(resPath)
}
\seealso{
\code{\link{pcglassoFast}} for a single‑λ blockwise optimizer.
}
