% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pcglassoFast.R
\name{pcglassoFast}
\alias{pcglassoFast}
\title{blockwise optimization for pcglasso}
\usage{
pcglassoFast(
  S,
  lambda,
  alpha,
  R = diag(dim(S)[1]),
  R_inv = solve(R),
  D = rep(1, dim(S)[1]),
  max_iter = 1000,
  tolerance = 0.001,
  tol_R = 1e-08,
  max_iter_R = 500,
  max_iter_R_outer = 5e+05,
  tol_D = 1e-08,
  max_iter_D_newton = 5000,
  max_iter_D_ls = 100,
  diagonal_Newton = TRUE,
  verbose = 0
)
}
\arguments{
\item{S}{(p x p matrix) empirical covariance matrix derived from the data.}

\item{lambda, alpha}{(double \eqn{0\le\lambda}, double \eqn{\alpha \in \mathbb{R}})
Parameters of the method. See Details section below.
\itemize{
\item \eqn{\lambda} is a penalty for off-diagonal
\item \eqn{\alpha} is a penalty for on-diagonal
}}

\item{R, R_inv}{(p x p matrix, unit diagonal) initial estimation of
precision matrix (it is recommended to left it default).}

\item{D}{(vector of length p) diagonal of initial estimation of diagonal
matrix (it is recommended to left it default).}

\item{max_iter}{(integer) maximum number of iterations.}

\item{tolerance}{(double) tolerance for convergence.}

\item{tol_R, max_iter_R_outer}{Parameters passed to \code{\link[=ROptimFortran]{ROptimFortran()}} function.}

\item{tol_D, max_iter_D_newton, max_iter_D_ls}{Parameters passed to \code{\link[=DOptim]{DOptim()}} function.}

\item{verbose}{(integer) print information about optimization process.
\itemize{
\item 0 -> no printing
\item 1 -> information about why the optimization has ended
\item 2 -> information about objective improvmenet
\item 3 -> information about tolerance adaptation for D optimization
\item 4 -> information about tolerance adaptation for R optimization
\item 5 -> details about the R matrix optimization
}}
}
\value{
list of three elements:
\itemize{
\item "R" - found correlation matrix
\item "D" - found diagonal matrix
\item "n_iters" - number of iterations of the outer loop
}
}
\description{
blockwise optimization for pcglasso
}
\details{
The function maximizes the
\eqn{f(R, D) = log(det(R)) + (1-\alpha)log(det(D^2)) - tr(DSDR) - \lambda ||R||_1}
function, where \eqn{||R||_1} is only for off-diagonal elements.

The function employs coordinate descent,
also known as blockwise optimization,
to iteratively optimize the variables \code{R} and \code{D}
while fixing the other variable.
It continues this process until convergence or
until the maximum number of iterations is reached.
}
\examples{
p <- 7
R.true <- toeplitz(c(c(1, -0.5), rep(0, p - 2)))
D.true <- sqrt(rchisq(p, 3))
S_inv.true <- diag(D.true) \%*\% R.true \%*\% diag(D.true)

S <- solve(S_inv.true) # data

alpha <- 4 / 20 # 4 / n, as in Carter's paper

pcglassoFast(S, 0.12, alpha, max_iter = 15, diagonal_Newton = TRUE, verbose = 3)
}
\seealso{
\code{\link[=pcglassoPath]{pcglassoPath()}} to compute a full λ‑path of solutions
}
