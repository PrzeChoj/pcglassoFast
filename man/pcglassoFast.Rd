% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pcglassoFast.R
\name{pcglassoFast}
\alias{pcglassoFast}
\title{blockwise optimization for pcglasso}
\usage{
pcglassoFast(
  S,
  lambda,
  alpha,
  R = diag(dim(S)[1]),
  R_inv = solve(R),
  D = rep(1, dim(S)[1]),
  max_iter = 100,
  tolerance = 1e-06,
  tol_R = 1e-04,
  max_iter_R_inner = 500,
  max_iter_R_outer = 100,
  tol_D = 1e-04,
  max_iter_D_newton = 500,
  max_iter_D_ls = 100,
  diagonal_Newton = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{S}{(p x p matrix) empirical covariance matrix derived from the data.}

\item{lambda, alpha}{(double \eqn{0\le\lambda}, double \eqn{\alpha \in \mathbb{R}})
Parameters of the method. See Details section below.
\itemize{
\item \eqn{\lambda} is a penalty for off-diagonal
\item \eqn{\alpha} is a penalty for on-diagonal
}}

\item{R, R_inv}{(p x p matrix, unit diagonal) initial estimation of
precision matrix (it is recommended to left it default).}

\item{D}{(vector of length p) diagonal of initial estimation of diagonal
matrix (it is recommended to left it default).}

\item{max_iter}{(integer) maximum number of iterations.}

\item{tolerance}{(double) tolerance for convergence.}

\item{tol_R, max_iter_R_inner, max_iter_R_outer}{Parameters passed to \code{\link[=ROptim]{ROptim()}} function.}

\item{tol_D, max_iter_D_newton, max_iter_D_ls}{Parameters passed to \code{\link[=DOptim]{DOptim()}} function.}

\item{verbose}{(boolian) print of loss.}
}
\value{
list of three elements:
\itemize{
\item "R" - found correlation matrix
\item "D" - found diagonal matrix
\item "n_iters" - number of iterations of the outer loop
}
}
\description{
blockwise optimization for pcglasso
}
\details{
The function maximizes the
\eqn{f(R, D) = log(det(R)) + (1-\alpha)log(det(D^2)) - tr(DSDR) - \lambda ||R||_1}
function, where \eqn{||R||_1} is only for off-diagonal elements.

The function employs coordinate descent,
also known as blockwise optimization,
to iteratively optimize the variables \code{R} and \code{D}
while fixing the other variable.
It continues this process until convergence or
until the maximum number of iterations is reached.
}
\examples{
p <- 7
R.true <- toeplitz(c(c(1, -0.5), rep(0, p - 2)))
D.true <- sqrt(rchisq(p, 3))
S_inv.true <- diag(D.true) \%*\% R.true \%*\% diag(D.true)

S <- solve(S_inv.true) # data

alpha <- 4 / 20 # 4 / n, as in Carter's paper

pcglassoFast(S, 0.11, alpha, max_iter = 15, diagonal_Newton = TRUE, verbose = TRUE)
}
\seealso{
\code{\link[=pcglassoPath]{pcglassoPath()}} to compute a full λ‑path of solutions
}
